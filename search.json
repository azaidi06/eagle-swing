[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/exploratory-data-analysis/eda_nb.html",
    "href": "posts/exploratory-data-analysis/eda_nb.html",
    "title": "Initial Video Analysis",
    "section": "",
    "text": "we have 28 total videos & the file names are: \n['IMG_1014', 'IMG_1017', 'IMG_1015', 'IMG_1018', 'IMG_1023', 'IMG_1016', 'IMG_1019', 'IMG_0851', 'IMG_0855', 'IMG_0856', 'IMG_0849', 'IMG_0860', 'IMG_0857', 'IMG_0852', 'IMG_0853', 'IMG_0858', 'IMG_0859', 'IMG_0854', 'IMG_0848', 'IMG_0861', 'IMG_1090', 'IMG_1087', 'IMG_1088', 'IMG_1092', 'IMG_1086', 'IMG_1093', 'IMG_1091', 'IMG_1089']\n\n\n\n\n\n\n\n177M    ../../../data/full_videos/jun8/IMG_0856.MOV\n4.0M    ../../../data/clips/accurate/IMG_0856_swing_3_score_2.mp4\n\n\n\n\n\n\n\nCode\nclass video_metadata():\n    def __init__(self, file_path):\n        self.file_path = file_path\n        self.metadata = self.get_metadata(self.file_path)\n        self.height = self.metadata['height']\n        self.width = self.metadata['width']\n        self.fps = self.get_fps(self.metadata)\n        self.minutes = self.get_duration(self.metadata, minutes=True)\n        self.seconds = self.get_duration(self.metadata)\n        self.bitrate = self.get_bitrate(self.metadata)\n\n    def aggregate_metadata(self):\n        return {'file_name': str(self.file_path).split('/')[-1],\n                'fps': self.fps,\n                'height': self.height,\n                'width': self.width,\n                'minutes': self.minutes,\n                'seconds': self.seconds,\n                'bitrate': self.bitrate,\n                'file_path': self.file_path,\n                }\n    def get_metadata(self, file_path):\n        '''\n        Sometimes the video metadata is not in the first stream??\n        '''\n        meta_list = ffmpeg.probe(file_path)['streams']\n        for meta in meta_list:\n            try: \n                meta['height']\n                return meta\n            except:\n                pass\n                 \n    def get_fps(self, metadata):\n        fps = metadata['r_frame_rate']\n        return round(eval(fps))\n\n    def get_duration(self, metadata, minutes=False):\n        seconds = round(float(metadata['duration']))\n        # returns time in minutes\n        if minutes: \n            return seconds / 60\n        else: return seconds\n\n    def get_bitrate(self, metadata):\n        ### returns bit rate in megabyte -- divide by 1000 for Kbs and once more for Mbs\n        bitrate = int(metadata['bit_rate']) / 1000 / 1000\n        return bitrate\n\n\n\n\nCode\nvideo_metadata(video_paths[12]).aggregate_metadata()\n\n\n{'file_name': 'IMG_0857.MOV',\n 'fps': 30,\n 'height': 1080,\n 'width': 1920,\n 'minutes': 2.55,\n 'seconds': 153,\n 'bitrate': 8.605271,\n 'file_path': Path('../../../data/full_videos/jun8/IMG_0857.MOV')}\n\n\n\n\n\n\n\n\n\n\n\nfile_name\nfps\nheight\nwidth\nminutes\nseconds\nbitrate\nfile_path\n\n\n\n\n0\nIMG_0848.MOV\n30\n1080\n1920\n4.383333\n263\n8.610146\n../../../data/full_videos/jun8/IMG_0848.MOV\n\n\n1\nIMG_0849.MOV\n30\n1080\n1920\n9.200000\n552\n8.583966\n../../../data/full_videos/jun8/IMG_0849.MOV\n\n\n2\nIMG_0851.MOV\n30\n960\n540\n2.866667\n172\n4.692317\n../../../data/full_videos/jun8/IMG_0851.MOV\n\n\n3\nIMG_0852.MOV\n30\n540\n960\n2.950000\n177\n1.370111\n../../../data/full_videos/jun8/IMG_0852.MOV\n\n\n4\nIMG_0853.MOV\n30\n540\n960\n2.716667\n163\n1.367803\n../../../data/full_videos/jun8/IMG_0853.MOV\n\n\n5\nIMG_0854.MOV\n30\n1080\n1920\n2.616667\n157\n8.607743\n../../../data/full_videos/jun8/IMG_0854.MOV\n\n\n6\nIMG_0855.MOV\n30\n1080\n1920\n2.966667\n178\n8.598368\n../../../data/full_videos/jun8/IMG_0855.MOV\n\n\n7\nIMG_0856.MOV\n30\n1080\n1920\n2.783333\n167\n8.588547\n../../../data/full_videos/jun8/IMG_0856.MOV\n\n\n8\nIMG_0857.MOV\n30\n1080\n1920\n2.550000\n153\n8.605271\n../../../data/full_videos/jun8/IMG_0857.MOV\n\n\n9\nIMG_0858.MOV\n30\n568\n320\n3.050000\n183\n1.865664\n../../../data/full_videos/jun8/IMG_0858.MOV\n\n\n10\nIMG_0859.MOV\n30\n1080\n1920\n2.516667\n151\n8.624519\n../../../data/full_videos/jun8/IMG_0859.MOV\n\n\n11\nIMG_0860.MOV\n30\n1920\n1080\n1.800000\n108\n10.544283\n../../../data/full_videos/jun8/IMG_0860.MOV\n\n\n12\nIMG_0861.MOV\n30\n1080\n1920\n7.216667\n433\n8.584579\n../../../data/full_videos/jun8/IMG_0861.MOV\n\n\n13\nIMG_1014.MOV\n60\n1080\n1920\n7.400000\n444\n13.103602\n../../../data/full_videos/aug9/IMG_1014.MOV\n\n\n14\nIMG_1015.MOV\n60\n1080\n1920\n6.550000\n393\n13.103961\n../../../data/full_videos/aug9/IMG_1015.MOV\n\n\n15\nIMG_1016.MOV\n60\n1080\n1920\n5.483333\n329\n13.110048\n../../../data/full_videos/aug9/IMG_1016.MOV\n\n\n16\nIMG_1017.MOV\n60\n1080\n1920\n2.866667\n172\n13.134301\n../../../data/full_videos/aug9/IMG_1017.MOV\n\n\n17\nIMG_1018.MOV\n30\n2160\n3840\n5.250000\n315\n25.100516\n../../../data/full_videos/aug9/IMG_1018.MOV\n\n\n18\nIMG_1019.MOV\n60\n2160\n3840\n4.650000\n279\n53.182729\n../../../data/full_videos/aug9/IMG_1019.MOV\n\n\n19\nIMG_1023.MOV\n60\n2160\n3840\n6.883333\n413\n56.143823\n../../../data/full_videos/aug9/IMG_1023.MOV\n\n\n20\nIMG_1086.MOV\n60\n1920\n1080\n2.883333\n173\n15.800221\n../../../data/full_videos/sep14/IMG_1086.MOV\n\n\n21\nIMG_1087.MOV\n60\n1920\n1080\n2.833333\n170\n15.820864\n../../../data/full_videos/sep14/IMG_1087.MOV\n\n\n22\nIMG_1088.MOV\n60\n1920\n1080\n2.433333\n146\n15.823184\n../../../data/full_videos/sep14/IMG_1088.MOV\n\n\n23\nIMG_1089.MOV\n60\n1920\n1080\n4.200000\n252\n15.795585\n../../../data/full_videos/sep14/IMG_1089.MOV\n\n\n24\nIMG_1090.MOV\n60\n1920\n1080\n3.383333\n203\n15.800890\n../../../data/full_videos/sep14/IMG_1090.MOV\n\n\n25\nIMG_1091.MOV\n60\n1920\n1080\n3.750000\n225\n15.787499\n../../../data/full_videos/sep14/IMG_1091.MOV\n\n\n26\nIMG_1092.MOV\n60\n1920\n1080\n3.200000\n192\n15.800213\n../../../data/full_videos/sep14/IMG_1092.MOV\n\n\n27\nIMG_1093.MOV\n60\n1920\n1080\n3.200000\n192\n15.792813\n../../../data/full_videos/sep14/IMG_1093.MOV\n\n\n\n\n\n\n\nNow we have a quick and easily understandable way to extract all the metadata relative to our videos and get a better understaning of where outliers may lie with respect to data quality or frame rate and also to better understand the overall distribution we have amongst our data"
  },
  {
    "objectID": "posts/exploratory-data-analysis/eda_nb.html#lets-take-a-look-at-our-full-videos-and-pull-some-metadata-from-them-in-case-we-need-this-information-later-on",
    "href": "posts/exploratory-data-analysis/eda_nb.html#lets-take-a-look-at-our-full-videos-and-pull-some-metadata-from-them-in-case-we-need-this-information-later-on",
    "title": "Initial Video Analysis",
    "section": "",
    "text": "we have 28 total videos & the file names are: \n['IMG_1014', 'IMG_1017', 'IMG_1015', 'IMG_1018', 'IMG_1023', 'IMG_1016', 'IMG_1019', 'IMG_0851', 'IMG_0855', 'IMG_0856', 'IMG_0849', 'IMG_0860', 'IMG_0857', 'IMG_0852', 'IMG_0853', 'IMG_0858', 'IMG_0859', 'IMG_0854', 'IMG_0848', 'IMG_0861', 'IMG_1090', 'IMG_1087', 'IMG_1088', 'IMG_1092', 'IMG_1086', 'IMG_1093', 'IMG_1091', 'IMG_1089']\n\n\n\n\n\n\n\n177M    ../../../data/full_videos/jun8/IMG_0856.MOV\n4.0M    ../../../data/clips/accurate/IMG_0856_swing_3_score_2.mp4\n\n\n\n\n\n\n\nCode\nclass video_metadata():\n    def __init__(self, file_path):\n        self.file_path = file_path\n        self.metadata = self.get_metadata(self.file_path)\n        self.height = self.metadata['height']\n        self.width = self.metadata['width']\n        self.fps = self.get_fps(self.metadata)\n        self.minutes = self.get_duration(self.metadata, minutes=True)\n        self.seconds = self.get_duration(self.metadata)\n        self.bitrate = self.get_bitrate(self.metadata)\n\n    def aggregate_metadata(self):\n        return {'file_name': str(self.file_path).split('/')[-1],\n                'fps': self.fps,\n                'height': self.height,\n                'width': self.width,\n                'minutes': self.minutes,\n                'seconds': self.seconds,\n                'bitrate': self.bitrate,\n                'file_path': self.file_path,\n                }\n    def get_metadata(self, file_path):\n        '''\n        Sometimes the video metadata is not in the first stream??\n        '''\n        meta_list = ffmpeg.probe(file_path)['streams']\n        for meta in meta_list:\n            try: \n                meta['height']\n                return meta\n            except:\n                pass\n                 \n    def get_fps(self, metadata):\n        fps = metadata['r_frame_rate']\n        return round(eval(fps))\n\n    def get_duration(self, metadata, minutes=False):\n        seconds = round(float(metadata['duration']))\n        # returns time in minutes\n        if minutes: \n            return seconds / 60\n        else: return seconds\n\n    def get_bitrate(self, metadata):\n        ### returns bit rate in megabyte -- divide by 1000 for Kbs and once more for Mbs\n        bitrate = int(metadata['bit_rate']) / 1000 / 1000\n        return bitrate\n\n\n\n\nCode\nvideo_metadata(video_paths[12]).aggregate_metadata()\n\n\n{'file_name': 'IMG_0857.MOV',\n 'fps': 30,\n 'height': 1080,\n 'width': 1920,\n 'minutes': 2.55,\n 'seconds': 153,\n 'bitrate': 8.605271,\n 'file_path': Path('../../../data/full_videos/jun8/IMG_0857.MOV')}\n\n\n\n\n\n\n\n\n\n\n\nfile_name\nfps\nheight\nwidth\nminutes\nseconds\nbitrate\nfile_path\n\n\n\n\n0\nIMG_0848.MOV\n30\n1080\n1920\n4.383333\n263\n8.610146\n../../../data/full_videos/jun8/IMG_0848.MOV\n\n\n1\nIMG_0849.MOV\n30\n1080\n1920\n9.200000\n552\n8.583966\n../../../data/full_videos/jun8/IMG_0849.MOV\n\n\n2\nIMG_0851.MOV\n30\n960\n540\n2.866667\n172\n4.692317\n../../../data/full_videos/jun8/IMG_0851.MOV\n\n\n3\nIMG_0852.MOV\n30\n540\n960\n2.950000\n177\n1.370111\n../../../data/full_videos/jun8/IMG_0852.MOV\n\n\n4\nIMG_0853.MOV\n30\n540\n960\n2.716667\n163\n1.367803\n../../../data/full_videos/jun8/IMG_0853.MOV\n\n\n5\nIMG_0854.MOV\n30\n1080\n1920\n2.616667\n157\n8.607743\n../../../data/full_videos/jun8/IMG_0854.MOV\n\n\n6\nIMG_0855.MOV\n30\n1080\n1920\n2.966667\n178\n8.598368\n../../../data/full_videos/jun8/IMG_0855.MOV\n\n\n7\nIMG_0856.MOV\n30\n1080\n1920\n2.783333\n167\n8.588547\n../../../data/full_videos/jun8/IMG_0856.MOV\n\n\n8\nIMG_0857.MOV\n30\n1080\n1920\n2.550000\n153\n8.605271\n../../../data/full_videos/jun8/IMG_0857.MOV\n\n\n9\nIMG_0858.MOV\n30\n568\n320\n3.050000\n183\n1.865664\n../../../data/full_videos/jun8/IMG_0858.MOV\n\n\n10\nIMG_0859.MOV\n30\n1080\n1920\n2.516667\n151\n8.624519\n../../../data/full_videos/jun8/IMG_0859.MOV\n\n\n11\nIMG_0860.MOV\n30\n1920\n1080\n1.800000\n108\n10.544283\n../../../data/full_videos/jun8/IMG_0860.MOV\n\n\n12\nIMG_0861.MOV\n30\n1080\n1920\n7.216667\n433\n8.584579\n../../../data/full_videos/jun8/IMG_0861.MOV\n\n\n13\nIMG_1014.MOV\n60\n1080\n1920\n7.400000\n444\n13.103602\n../../../data/full_videos/aug9/IMG_1014.MOV\n\n\n14\nIMG_1015.MOV\n60\n1080\n1920\n6.550000\n393\n13.103961\n../../../data/full_videos/aug9/IMG_1015.MOV\n\n\n15\nIMG_1016.MOV\n60\n1080\n1920\n5.483333\n329\n13.110048\n../../../data/full_videos/aug9/IMG_1016.MOV\n\n\n16\nIMG_1017.MOV\n60\n1080\n1920\n2.866667\n172\n13.134301\n../../../data/full_videos/aug9/IMG_1017.MOV\n\n\n17\nIMG_1018.MOV\n30\n2160\n3840\n5.250000\n315\n25.100516\n../../../data/full_videos/aug9/IMG_1018.MOV\n\n\n18\nIMG_1019.MOV\n60\n2160\n3840\n4.650000\n279\n53.182729\n../../../data/full_videos/aug9/IMG_1019.MOV\n\n\n19\nIMG_1023.MOV\n60\n2160\n3840\n6.883333\n413\n56.143823\n../../../data/full_videos/aug9/IMG_1023.MOV\n\n\n20\nIMG_1086.MOV\n60\n1920\n1080\n2.883333\n173\n15.800221\n../../../data/full_videos/sep14/IMG_1086.MOV\n\n\n21\nIMG_1087.MOV\n60\n1920\n1080\n2.833333\n170\n15.820864\n../../../data/full_videos/sep14/IMG_1087.MOV\n\n\n22\nIMG_1088.MOV\n60\n1920\n1080\n2.433333\n146\n15.823184\n../../../data/full_videos/sep14/IMG_1088.MOV\n\n\n23\nIMG_1089.MOV\n60\n1920\n1080\n4.200000\n252\n15.795585\n../../../data/full_videos/sep14/IMG_1089.MOV\n\n\n24\nIMG_1090.MOV\n60\n1920\n1080\n3.383333\n203\n15.800890\n../../../data/full_videos/sep14/IMG_1090.MOV\n\n\n25\nIMG_1091.MOV\n60\n1920\n1080\n3.750000\n225\n15.787499\n../../../data/full_videos/sep14/IMG_1091.MOV\n\n\n26\nIMG_1092.MOV\n60\n1920\n1080\n3.200000\n192\n15.800213\n../../../data/full_videos/sep14/IMG_1092.MOV\n\n\n27\nIMG_1093.MOV\n60\n1920\n1080\n3.200000\n192\n15.792813\n../../../data/full_videos/sep14/IMG_1093.MOV\n\n\n\n\n\n\n\nNow we have a quick and easily understandable way to extract all the metadata relative to our videos and get a better understaning of where outliers may lie with respect to data quality or frame rate and also to better understand the overall distribution we have amongst our data"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Eagle Swing Takes Off",
    "section": "",
    "text": "This is the first post in the R&D page for Eagle Swing. Welcome!\n\nThe idea behind Eagle Swing is simple, some days you have a good day at the range and sometimes you can’t figure out all the things you’re off on. Here, we take in a recorded video of a driving range session and then after processing the video with our models –&gt; we can generate insights into what you are doing when you hit your best swing compared to those swings where you can’t seem to connect.\nThis repo and website will be organized in a specific fashion, in creating the end product, we’ll run into a ton of questions along the way that need to be answered. In this pursuit, each notebook/post will be featuring a specific problem that needs further exploration, sometimes code will be generated within the notebook for further use, while sometimes that code will be only useful for the small and specific purpose of the task at hand."
  },
  {
    "objectID": "posts/labeling/label.html",
    "href": "posts/labeling/label.html",
    "title": "Auto Label",
    "section": "",
    "text": "Code\nfrom fastai.vision.all import *\n\n\n\n\nCode\nfiles = get_files('.')\nfile\n\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[4], line 2\n      1 files = get_files('.')\n----&gt; 2 file\n\nNameError: name 'file' is not defined\n\n\n\nTake the back half of auto-clipper and bring it here"
  },
  {
    "objectID": "posts/analyze/analysis.html",
    "href": "posts/analyze/analysis.html",
    "title": "Kinematic Analysis",
    "section": "",
    "text": "Code\nfrom fastai.vision.all import *\nfrom swing_data import *\n\n\n\n\nCode\nbase_path = '../../../data/full_videos'\nswing_days = ['jun8', 'aug9', 'sep14']\nparent_dir = f'{base_path}/{swing_days[-1]}'\nparent_dir\n\n\n'../../../data/full_videos/sep14'\n\n\n\n\nCode\nfiles_names = [file.name.split('.')[0] for file in get_files(f'{base_path}/{swing_days[-1]}', extensions='.MOV') ]\nprint(files_names)\n\n\n['IMG_1090', 'IMG_1087', 'IMG_1088', 'IMG_1092', 'IMG_1086', 'IMG_1093', 'IMG_1091', 'IMG_1089']\n\n\n\n\nCode\nkp_folder_paths_dict = {fname: f'{parent_dir}/{fname}/keypoints' for fname in files_names}\nkp_folder_paths_dict\n\n\n{'IMG_1090': '../../../data/full_videos/sep14/IMG_1090/keypoints',\n 'IMG_1087': '../../../data/full_videos/sep14/IMG_1087/keypoints',\n 'IMG_1088': '../../../data/full_videos/sep14/IMG_1088/keypoints',\n 'IMG_1092': '../../../data/full_videos/sep14/IMG_1092/keypoints',\n 'IMG_1086': '../../../data/full_videos/sep14/IMG_1086/keypoints',\n 'IMG_1093': '../../../data/full_videos/sep14/IMG_1093/keypoints',\n 'IMG_1091': '../../../data/full_videos/sep14/IMG_1091/keypoints',\n 'IMG_1089': '../../../data/full_videos/sep14/IMG_1089/keypoints'}\n\n\n\n\nCode\ndef get_kps(folder):\n    all_files = get_files(folder, extensions='.pkl')\n    clip_files = [file for file in all_files if file.name[:3] == 'IMG']\n    return clip_files\n\n\n\n\nCode\n[len(get_kps(folder_path)) for folder_path in kp_folder_paths_dict.values()]\n\n\n[6, 5, 5, 6, 5, 7, 6, 7]\n\n\n\n\nCode\nIMG_1086 = [2, 1, 1, 5, 5] #5\nIMG_1087 = [4, 5, 2, 1, 2] # 5\nIMG_1088 = [1, 1, 3, 3, 2] # 5\nIMG_1089 = [4, 3, 3, 4, 3, 4, 3] #7\nIMG_1090 = [4, 1, 4, 1, 1, 1] #6\nIMG_1091 = ['**', 2, 2, 5, 2, 4, 1] #6 - 7 w/practice --&gt; start 30 seconds in\n### *** —&gt; practice swing w/o score\nIMG_1092 = [4, 1, 4, 1, 1, 1,] # 6\nIMG_1093 = [1, 3, 1, 2, 1, '**', 2] # 6 - 7 w/practice --&gt; just drop second to last clip\n\n\n\n\nCode\nsorted_fnames = sorted(list(kp_folder_paths_dict.keys()))\nprint(sorted_fnames)\n\n\n['IMG_1086', 'IMG_1087', 'IMG_1088', 'IMG_1089', 'IMG_1090', 'IMG_1091', 'IMG_1092', 'IMG_1093']\n\n\n\n\nCode\nkp_folder_paths_dict = [get_kps(f'{parent_dir}/{fname}/keypoints').__len__() for fname in sorted_fnames]\nkp_folder_paths_dict\n\n\n[5, 5, 5, 7, 6, 6, 6, 7]\n\n\n\n\nCode\nimport pandas as pd\ndf = pd.read_csv(f'{parent_dir}/IMG_1091/IMG_1091.csv')\ndf\n\n\n\n\n\n\n\n\n\nswing_idx\nstart_idx\nend_idx\n\n\n\n\n0\n0\n1393\n1573\n\n\n1\n1\n4010\n4190\n\n\n2\n2\n5951\n6131\n\n\n3\n3\n8380\n8560\n\n\n4\n4\n10040\n10220\n\n\n5\n5\n12562\n12742\n\n\n\n\n\n\n\n\n\nCode\ndf.start_idx//60\n\n\n0     23\n1     66\n2     99\n3    139\n4    167\n5    209\nName: start_idx, dtype: int64\n\n\n\n\nCode\ndf = pd.read_csv(f'{parent_dir}/IMG_1093/IMG_1093.csv')\ndf\n\n\n\n\n\n\n\n\n\nswing_idx\nstart_idx\nend_idx\n\n\n\n\n0\n0\n1585\n1765\n\n\n1\n1\n3123\n3303\n\n\n2\n2\n4856\n5036\n\n\n3\n3\n6091\n6271\n\n\n4\n4\n8090\n8270\n\n\n5\n5\n9228\n9408\n\n\n6\n6\n10320\n10500\n\n\n\n\n\n\n\n\n\nCode\ndf.start_idx//60\n\n\n0     26\n1     52\n2     80\n3    101\n4    134\n5    153\n6    172\nName: start_idx, dtype: int64"
  },
  {
    "objectID": "posts/manual_clipping/00a_data_clipping.html",
    "href": "posts/manual_clipping/00a_data_clipping.html",
    "title": "Video Clipping",
    "section": "",
    "text": "1) csv with the appropriate information about original videos, swings\n2) ffmpeg commands that will dictate how the video is decoded/encoded to generate the clips\n     - Since videos are from an iphone --&gt; there are some peculiarities to consider: \n         - https://www.perplexity.ai/search/8176d69e-475a-4e7f-ba07-0b762adb7c65\nWe'll then create an appropriate clipped folder within folder holding all the full videos from a specific date\n\n\nCode\nbase_path = '../../../data/full_videos'\nswing_days = ['jun8', 'aug9', 'sep14']\nfiles = get_files(f'{base_path}/{swing_days[0]}', extensions='.MOV')\nlen(files), files[0]\n\n\n(13, Path('../../../data/full_videos/jun8/IMG_0851.MOV'))\n\n\n\n\nCode\ndf_jun8 = pd.read_csv(f'{base_path}/{swing_days[0]}/cleaned.csv').reset_index(drop=True)\ndf_aug9 = pd.read_csv(f'{base_path}/{swing_days[1]}/cleaned.csv').reset_index(drop=True)\ndf_sep14 = pd.read_csv(f'{base_path}/{swing_days[2]}/cleaned.csv').reset_index(drop=True)\ndf_jun8.head(1)\n\n\n\n\n\n\n\n\n\ninput_file\nswing_index\nscore\nstart\nend\noutput_file\n\n\n\n\n0\nIMG_0848.MOV\n0\n2\n00:20\n00:23\nIMG_0848_swing_0_score_2.mp4\n\n\n\n\n\n\n\n\n\nCode\n# just checking that the dataframe columns are the same\nassert((df_aug9.columns == df_jun8.columns).sum() == len(df_aug9.columns))\nassert((df_aug9.columns == df_sep14.columns).sum() == len(df_aug9.columns))\n\n\n\n\nCode\n## All the necessary code to take a dataframe and clip the videos however we need\n\ndef clip_videos(df, \n                input_path, \n                crf='18',\n                video_encoder='copy',\n                debug=False):\n    output_folder_path = f'{input_path}/crf_{crf}_vcodec_{video_encoder}'\n    for idx in range(len(df)):\n        make_clip(input_folder_path=input_path, \n                  output_folder_path=output_folder_path,\n                  row=df.iloc[idx],\n                 crf=crf,\n                 vcodec=video_encoder)\n        if debug: break\n    assert(len(os.listdir(output_folder_path)) == len(df))\n\ndef make_output_filename(row):\n    return f'{row.input_file.split(\".\")[0]}_swing_{row.swing_index}_score_{row.score}.mp4'\n\ndef make_clip(input_folder_path, \n              output_folder_path,\n              row, \n              time='0:03',\n              crf='18',\n              vcodec='copy'):\n    input_file_name = row.input_file\n    output_file_name = make_output_filename(row)\n    start = row.start\n    input_file_path = f'{input_folder_path}/{input_file_name}'\n    output_file_path = f'{output_folder_path}/{output_file_name}'\n    if os.path.isdir(output_folder_path) is False:\n        os.mkdir(output_folder_path)\n    ffmpeg.input(input_file_path, \n                 ss=start)\\\n        .output(output_file_path, \n                t=time, \n                vcodec=vcodec,\n                crf=crf, \n                acodec='aac',\n                y=None) \\\n        .global_args('-movflags', '+faststart') \\\n        .run()\n\n\n\n\nCode\n#clip_videos(df_sep14, input_path=f'{base_path}/{swing_days[2]}', video_encoder='libx264', crf=0)\n\n\n\n\nCode\n## clip_videos(df_aug9, input_path=f'{base_path}/{swing_days[1]}', video_encoder='libx264', crf=0)\n\n\n\n\nCode\n! python\n\n\nPython 3.10.11 (main, May 16 2023, 00:28:57) [GCC 11.2.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; \nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nKeyboardInterrupt\n&gt;&gt;&gt; \n\n\n\n\nCode\n#clip_videos(df_aug9, input_path=f'{base_path}/{swing_days[1]}')\n\n\n\n\nCode\n#clip_videos(df_sep14, input_path=f'{base_path}/{swing_days[2]}')"
  },
  {
    "objectID": "posts/manual_clipping/00a_data_clipping.html#lets-work-on-creating-a-programmatic-way-to-receive-clip-full-videos-into-clips-of-individual-swings",
    "href": "posts/manual_clipping/00a_data_clipping.html#lets-work-on-creating-a-programmatic-way-to-receive-clip-full-videos-into-clips-of-individual-swings",
    "title": "Video Clipping",
    "section": "",
    "text": "1) csv with the appropriate information about original videos, swings\n2) ffmpeg commands that will dictate how the video is decoded/encoded to generate the clips\n     - Since videos are from an iphone --&gt; there are some peculiarities to consider: \n         - https://www.perplexity.ai/search/8176d69e-475a-4e7f-ba07-0b762adb7c65\nWe'll then create an appropriate clipped folder within folder holding all the full videos from a specific date\n\n\nCode\nbase_path = '../../../data/full_videos'\nswing_days = ['jun8', 'aug9', 'sep14']\nfiles = get_files(f'{base_path}/{swing_days[0]}', extensions='.MOV')\nlen(files), files[0]\n\n\n(13, Path('../../../data/full_videos/jun8/IMG_0851.MOV'))\n\n\n\n\nCode\ndf_jun8 = pd.read_csv(f'{base_path}/{swing_days[0]}/cleaned.csv').reset_index(drop=True)\ndf_aug9 = pd.read_csv(f'{base_path}/{swing_days[1]}/cleaned.csv').reset_index(drop=True)\ndf_sep14 = pd.read_csv(f'{base_path}/{swing_days[2]}/cleaned.csv').reset_index(drop=True)\ndf_jun8.head(1)\n\n\n\n\n\n\n\n\n\ninput_file\nswing_index\nscore\nstart\nend\noutput_file\n\n\n\n\n0\nIMG_0848.MOV\n0\n2\n00:20\n00:23\nIMG_0848_swing_0_score_2.mp4\n\n\n\n\n\n\n\n\n\nCode\n# just checking that the dataframe columns are the same\nassert((df_aug9.columns == df_jun8.columns).sum() == len(df_aug9.columns))\nassert((df_aug9.columns == df_sep14.columns).sum() == len(df_aug9.columns))\n\n\n\n\nCode\n## All the necessary code to take a dataframe and clip the videos however we need\n\ndef clip_videos(df, \n                input_path, \n                crf='18',\n                video_encoder='copy',\n                debug=False):\n    output_folder_path = f'{input_path}/crf_{crf}_vcodec_{video_encoder}'\n    for idx in range(len(df)):\n        make_clip(input_folder_path=input_path, \n                  output_folder_path=output_folder_path,\n                  row=df.iloc[idx],\n                 crf=crf,\n                 vcodec=video_encoder)\n        if debug: break\n    assert(len(os.listdir(output_folder_path)) == len(df))\n\ndef make_output_filename(row):\n    return f'{row.input_file.split(\".\")[0]}_swing_{row.swing_index}_score_{row.score}.mp4'\n\ndef make_clip(input_folder_path, \n              output_folder_path,\n              row, \n              time='0:03',\n              crf='18',\n              vcodec='copy'):\n    input_file_name = row.input_file\n    output_file_name = make_output_filename(row)\n    start = row.start\n    input_file_path = f'{input_folder_path}/{input_file_name}'\n    output_file_path = f'{output_folder_path}/{output_file_name}'\n    if os.path.isdir(output_folder_path) is False:\n        os.mkdir(output_folder_path)\n    ffmpeg.input(input_file_path, \n                 ss=start)\\\n        .output(output_file_path, \n                t=time, \n                vcodec=vcodec,\n                crf=crf, \n                acodec='aac',\n                y=None) \\\n        .global_args('-movflags', '+faststart') \\\n        .run()\n\n\n\n\nCode\n#clip_videos(df_sep14, input_path=f'{base_path}/{swing_days[2]}', video_encoder='libx264', crf=0)\n\n\n\n\nCode\n## clip_videos(df_aug9, input_path=f'{base_path}/{swing_days[1]}', video_encoder='libx264', crf=0)\n\n\n\n\nCode\n! python\n\n\nPython 3.10.11 (main, May 16 2023, 00:28:57) [GCC 11.2.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; \nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nKeyboardInterrupt\n&gt;&gt;&gt; \n\n\n\n\nCode\n#clip_videos(df_aug9, input_path=f'{base_path}/{swing_days[1]}')\n\n\n\n\nCode\n#clip_videos(df_sep14, input_path=f'{base_path}/{swing_days[2]}')"
  },
  {
    "objectID": "posts/manual_clipping/00a_data_clipping.html#now-some-code-to-pull-down-the-frames",
    "href": "posts/manual_clipping/00a_data_clipping.html#now-some-code-to-pull-down-the-frames",
    "title": "Video Clipping",
    "section": "Now some code to pull down the frames",
    "text": "Now some code to pull down the frames\n\n\nCode\ndef get_frames(swing_path, \n               resize=True, \n               width=256, \n               height=256,\n               debug=False):\n    capture = cv2.VideoCapture(swing_path)\n    frame_count = int(capture.get(cv2.CAP_PROP_FRAME_COUNT))\n    frame_width = int(capture.get(cv2.CAP_PROP_FRAME_WIDTH))\n    frame_height = int(capture.get(cv2.CAP_PROP_FRAME_HEIGHT))\n    video_array = np.empty((frame_count, frame_height, frame_width, 3), dtype=np.uint8)\n    idx = 0\n    while idx &lt; frame_count:\n        ret, frame = capture.read()\n        if not ret:\n            break\n        video_array[idx] = frame\n        idx += 1\n\n    capture.release()\n    if debug:\n        print(video_array.shape)\n    video_array = [convert_rgb(frame) for frame in video_array]\n    if resize:\n        video_array = np.array([resize_frame(frame, width, height) for frame in video_array])\n    return video_array\n\ndef resize_frame(frame, width=256, height=256):\n    return cv2.resize(frame, (width, height))\n\ndef convert_rgb(frame):\n    return cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n\ndef plot_three(image1, image2, image3=None):\n    # Create figure with 1 row, 3 columns of subplots\n    if image3 is None:\n        fig, axes = plt.subplots(1, 2, figsize=(15, 5))\n    else:\n        fig, axes = plt.subplots(1, 3, figsize=(15, 5))\n\n    # Plot each image on its respective axis\n    axes[0].imshow(image1)\n    axes[0].set_title('Frame 1')\n    axes[0].axis('off')  # Remove axis ticks and labels\n\n    axes[1].imshow(image2)\n    axes[1].set_title('Frame 2')\n    axes[1].axis('off')\n\n    if image3 is not None:\n        axes[2].imshow(image3)\n        axes[2].set_title('Frame 3 or Diff')\n        axes[2].axis('off')\n\n    plt.tight_layout()  # Adjust spacing between subplots\n    plt.show()\n\n\n\n\nCode\njun8_files = get_files(f'{base_path}/jun8/crf_18_vcodec_copy')\naug19_files = get_files(f'{base_path}/aug9/crf_18_vcodec_copy')\nsep14_files = get_files(f'{base_path}/sep14/crf_18_vcodec_copy')\nlen(jun8_files), len(aug19_files), len(sep14_files)\n\n\n(85, 78, 46)\n\n\n\n\nCode\njun_files_18 = get_files(f'{base_path}/jun8/crf_18_vcodec_copy')\njun_files_0 = get_files(f'{base_path}/jun8/crf_0_vcodec_libx264')\n\n\n\n\nCode\njun_files_18[0], jun_files_0[0]\n\n\n(Path('../../../data/full_videos/jun8/crf_18_vcodec_copy/IMG_0848_swing_0_score_2.mp4'),\n Path('../../../data/full_videos/jun8/crf_0_vcodec_libx264/IMG_0848_swing_0_score_2.mp4'))\n\n\n\n\nCode\naug19_files\n\n\n(#78) [Path('../../../data/full_videos/aug9/crf_18_vcodec_copy/IMG_1014_swing_10_score_1.mp4'),Path('../../../data/full_videos/aug9/crf_18_vcodec_copy/IMG_1023_swing_4_score_5.mp4'),Path('../../../data/full_videos/aug9/crf_18_vcodec_copy/IMG_1015_swing_10_score_4.mp4'),Path('../../../data/full_videos/aug9/crf_18_vcodec_copy/IMG_1015_swing_6_score_1.mp4'),Path('../../../data/full_videos/aug9/crf_18_vcodec_copy/IMG_1018_swing_0_score_4.mp4'),Path('../../../data/full_videos/aug9/crf_18_vcodec_copy/IMG_1023_swing_0_score_1.mp4'),Path('../../../data/full_videos/aug9/crf_18_vcodec_copy/IMG_1023_swing_13_score_3.mp4'),Path('../../../data/full_videos/aug9/crf_18_vcodec_copy/IMG_1017_swing_2_score_4.mp4'),Path('../../../data/full_videos/aug9/crf_18_vcodec_copy/IMG_1014_swing_5_score_3.mp4'),Path('../../../data/full_videos/aug9/crf_18_vcodec_copy/IMG_1023_swing_12_score_1.mp4'),Path('../../../data/full_videos/aug9/crf_18_vcodec_copy/IMG_1019_swing_7_score_1.mp4'),Path('../../../data/full_videos/aug9/crf_18_vcodec_copy/IMG_1014_swing_6_score_2.mp4'),Path('../../../data/full_videos/aug9/crf_18_vcodec_copy/IMG_1015_swing_1_score_1.mp4'),Path('../../../data/full_videos/aug9/crf_18_vcodec_copy/IMG_1018_swing_3_score_2.mp4'),Path('../../../data/full_videos/aug9/crf_18_vcodec_copy/IMG_1023_swing_5_score_5.mp4'),Path('../../../data/full_videos/aug9/crf_18_vcodec_copy/IMG_1015_swing_8_score_1.mp4'),Path('../../../data/full_videos/aug9/crf_18_vcodec_copy/IMG_1018_swing_9_score_5.mp4'),Path('../../../data/full_videos/aug9/crf_18_vcodec_copy/IMG_1014_swing_13_score_3.mp4'),Path('../../../data/full_videos/aug9/crf_18_vcodec_copy/IMG_1017_swing_4_score_5.mp4'),Path('../../../data/full_videos/aug9/crf_18_vcodec_copy/IMG_1016_swing_0_score_4.mp4')...]\n\n\n\n\nCode\nVideo(aug19_files[0], width=200, height=300)\n\n\n\n      Your browser does not support the video element.\n    \n\n\n\n\nCode\nVideo(jun8_files[0], width=200, height=300)\n\n\n\n      Your browser does not support the video element.\n    \n\n\n\n\nCode\n#Video??"
  },
  {
    "objectID": "posts/init_auto_swing_extraction/init_exploration.html",
    "href": "posts/init_auto_swing_extraction/init_exploration.html",
    "title": "Initial forays into auto-detect function of longer videos",
    "section": "",
    "text": "1) 2d keypoints of a full video\n2) Find the most relevant frames that correspond to a swing\n3) Crop and extract a corresponding video for each swing\n\n\n\n\n\nThe start times of every swing in IMG_1090.MOV are:\n ['0:28', '0:53', '1:27', '1:54', '2:25', '3:01']\n\n\n\n\n\n\nCode\nprint(f'Grabbing a clip from {files[0].name}')\nframes, fps = get_frames(files[0], \n                         per_second=False, # only grab every fps frame\n                         start_idx=600, # start 10 seconds in\n                         #start_idx=1200, # start 20 seconds in\n                         num_frames=1500, # only pull down 25 seconds of video\n                         #num_frames=250, # only pull down 4ish seconds of video)\n                         resize_dim=(256,256),\n                         show_progress=True\n                        )\nsave_frames(frames=frames, fps=fps, fname='useless_frames.mp4')\n\n\nGrabbing a clip from IMG_1090.MOV\n\n\n100%|████████████████████████████████████████████████████████████████████████████| 1500/1500 [02:34&lt;00:00,  9.68it/s]\n\n\n\n\n\n\n\n\nFirst 10 seconds are useless and not included\nOnly about 3 seconds of the first 35 seconds is relevant\nThe full video has 6 swings and is over 3 minutes long!\n\n\n\n\n\nI tried a few different approaches that did not work very consistently or well at all\nAfter a few days lets see if a simple approach will get the job done\nWe only want a close approximation of something in the middle of the swing frames themselves, once we have it, we can just pull 1-2 seconds before and after this middle frame\n\n\nusing our existing physics code to normalize the swings around the peak of the backswing like we’ve already fleshed out (shown to work)\n\n\n\n\n\n\nThe simple extraction method will be to use a filter on 2d keypoints and say yes to any frame where both hands are above the shoulder\n\nIf both hands are above the shoulders, we know we’re inside of a swing frames\nWhen giving the score, one hand is above the shoulder, so we need BOTH above\n\n\n\n\nCode\n# logger = MMLogger.get_instance('mmpose')\n# logger.setLevel('ERROR')  # or 'ERROR' for even less output\n# labeler = get_labeler('vit');\n# generate_labels(labeler, 'useless_frames.mp4', out_dir='keypoints');\n\n\n\n\n\n\n\nFirst\nOnly\nThe\n\n\n\nCode\nfrom swing_data import *\nkps = KpExtractor('keypoints/useless_frames.pkl').keypoint_data.kps\nkps.shape, kps[0,9]\n\n\n\n\nCode\nl_shoulder = kps[:, 5, 1] # Left Wrist KP\nr_shoulder = kps[:, 6, 1] # Right Wrist KP\nl_elbow = kps[:, 7, 1] # Left Elbow KP\nr_elbow = kps[:, 8, 1] # Right Elbow KP\nl_wrist = kps[:, 9, 1] # Left Wrist KP\nr_wrist = kps[:, 10, 1] # Right Wrist KP\n# less than is above\nleft_wrist_above_elbow = l_wrist &lt; l_elbow\nright_wrist_above_elbow = r_wrist &lt; r_elbow\nleft_wrist_above_sh = l_wrist &lt; l_shoulder\nright_wrist_above_sh = r_wrist &lt; r_shoulder\n\n\n\n\nCode\ncombined_true = left_wrist_above_elbow & right_wrist_above_elbow & left_wrist_above_sh & right_wrist_above_sh\nhigher_idxs = np.where(combined_true)[0]\nprint(f'There are {len(higher_idxs)} frames with the wrists above the elbow and shoulders')\n\n\nThere are 77 frames with the wrists above the elbow and shoulders\n\n\n\n\nCode\nhigher_frames = np.stack([frames[idx] for idx in higher_idxs])\nsave_frames(fname='higher_frames.mp4', frames=higher_frames)\nhigher_frames.shape\n\n\n(77, 256, 256, 3)\n\n\n\n\n\n\n\n…\n\n\n\nCode\nfirst_high_idx = higher_idxs[0]\nfirst_high_idx\n\n\n1150\n\n\n\n\nCode\n# get 1.5 seconds before and after first high index\ninit_idx = first_high_idx - 90\nfinal_idx = first_high_idx + 90\ninit_idx, final_idx\n\n\n(1060, 1240)\n\n\n\n\n\n\n\n…\n\nFirst 90 seconds of video\n\n…\nFirst 90 seconds of video clipped!\n\n…"
  },
  {
    "objectID": "posts/init_auto_swing_extraction/init_exploration.html#ive-been-hand-labeling-the-videos-and-then-extracting-clips-from-my-own-labels-this-is-not-feasible-to-do-in-a-timely-manner-and-requires-alot-of-manual-labor.-lets-find-a-way-to",
    "href": "posts/init_auto_swing_extraction/init_exploration.html#ive-been-hand-labeling-the-videos-and-then-extracting-clips-from-my-own-labels-this-is-not-feasible-to-do-in-a-timely-manner-and-requires-alot-of-manual-labor.-lets-find-a-way-to",
    "title": "Initial forays into auto-detect function of longer videos",
    "section": "",
    "text": "1) 2d keypoints of a full video\n2) Find the most relevant frames that correspond to a swing\n3) Crop and extract a corresponding video for each swing\n\n\n\n\n\nThe start times of every swing in IMG_1090.MOV are:\n ['0:28', '0:53', '1:27', '1:54', '2:25', '3:01']\n\n\n\n\n\n\nCode\nprint(f'Grabbing a clip from {files[0].name}')\nframes, fps = get_frames(files[0], \n                         per_second=False, # only grab every fps frame\n                         start_idx=600, # start 10 seconds in\n                         #start_idx=1200, # start 20 seconds in\n                         num_frames=1500, # only pull down 25 seconds of video\n                         #num_frames=250, # only pull down 4ish seconds of video)\n                         resize_dim=(256,256),\n                         show_progress=True\n                        )\nsave_frames(frames=frames, fps=fps, fname='useless_frames.mp4')\n\n\nGrabbing a clip from IMG_1090.MOV\n\n\n100%|████████████████████████████████████████████████████████████████████████████| 1500/1500 [02:34&lt;00:00,  9.68it/s]\n\n\n\n\n\n\n\n\nFirst 10 seconds are useless and not included\nOnly about 3 seconds of the first 35 seconds is relevant\nThe full video has 6 swings and is over 3 minutes long!\n\n\n\n\n\nI tried a few different approaches that did not work very consistently or well at all\nAfter a few days lets see if a simple approach will get the job done\nWe only want a close approximation of something in the middle of the swing frames themselves, once we have it, we can just pull 1-2 seconds before and after this middle frame\n\n\nusing our existing physics code to normalize the swings around the peak of the backswing like we’ve already fleshed out (shown to work)\n\n\n\n\n\n\nThe simple extraction method will be to use a filter on 2d keypoints and say yes to any frame where both hands are above the shoulder\n\nIf both hands are above the shoulders, we know we’re inside of a swing frames\nWhen giving the score, one hand is above the shoulder, so we need BOTH above\n\n\n\n\nCode\n# logger = MMLogger.get_instance('mmpose')\n# logger.setLevel('ERROR')  # or 'ERROR' for even less output\n# labeler = get_labeler('vit');\n# generate_labels(labeler, 'useless_frames.mp4', out_dir='keypoints');\n\n\n\n\n\n\n\nFirst\nOnly\nThe\n\n\n\nCode\nfrom swing_data import *\nkps = KpExtractor('keypoints/useless_frames.pkl').keypoint_data.kps\nkps.shape, kps[0,9]\n\n\n\n\nCode\nl_shoulder = kps[:, 5, 1] # Left Wrist KP\nr_shoulder = kps[:, 6, 1] # Right Wrist KP\nl_elbow = kps[:, 7, 1] # Left Elbow KP\nr_elbow = kps[:, 8, 1] # Right Elbow KP\nl_wrist = kps[:, 9, 1] # Left Wrist KP\nr_wrist = kps[:, 10, 1] # Right Wrist KP\n# less than is above\nleft_wrist_above_elbow = l_wrist &lt; l_elbow\nright_wrist_above_elbow = r_wrist &lt; r_elbow\nleft_wrist_above_sh = l_wrist &lt; l_shoulder\nright_wrist_above_sh = r_wrist &lt; r_shoulder\n\n\n\n\nCode\ncombined_true = left_wrist_above_elbow & right_wrist_above_elbow & left_wrist_above_sh & right_wrist_above_sh\nhigher_idxs = np.where(combined_true)[0]\nprint(f'There are {len(higher_idxs)} frames with the wrists above the elbow and shoulders')\n\n\nThere are 77 frames with the wrists above the elbow and shoulders\n\n\n\n\nCode\nhigher_frames = np.stack([frames[idx] for idx in higher_idxs])\nsave_frames(fname='higher_frames.mp4', frames=higher_frames)\nhigher_frames.shape\n\n\n(77, 256, 256, 3)\n\n\n\n\n\n\n\n…\n\n\n\nCode\nfirst_high_idx = higher_idxs[0]\nfirst_high_idx\n\n\n1150\n\n\n\n\nCode\n# get 1.5 seconds before and after first high index\ninit_idx = first_high_idx - 90\nfinal_idx = first_high_idx + 90\ninit_idx, final_idx\n\n\n(1060, 1240)\n\n\n\n\n\n\n\n…\n\nFirst 90 seconds of video\n\n…\nFirst 90 seconds of video clipped!\n\n…"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "eagle-swing",
    "section": "",
    "text": "Kinematic Analysis\n\n\n\nData Visualization\n\n\n\nNow that we have our labeled clips, lets run some preliminary analysis over each of their keypoints and see what we can extract\n\n\n\n\n\nNov 15, 2025\n\n\nAli Zaidi\n\n\n\n\n\n\n\n\n\n\n\n\nAuto Label\n\n\n\nData Engineering\n\n\n\nNow that we have our clipped video files, lets label them at full precision\n\n\n\n\n\nNov 14, 2025\n\n\nAli Zaidi\n\n\n\n\n\n\n\n\n\n\n\n\nInitial forays into auto-detect function of longer videos\n\n\n\nData Engineering\n\n\n\nFleshing out a way to find a consistent point in the swing to use for autodetection of swings\n\n\n\n\n\nNov 10, 2025\n\n\nAli Zaidi\n\n\n\n\n\n\n\n\n\n\n\n\nVideo Clipping\n\n\n\nData Engineering\n\n\n\nA manual approach to hand labeling clipping videos\n\n\n\n\n\nSep 25, 2025\n\n\nAli Zaidi\n\n\n\n\n\n\n\n\n\n\n\n\nInitial Video Analysis\n\n\n\nEDA\n\n\n\n\n\n\n\n\n\nSep 22, 2025\n\n\nAli Zaidi\n\n\n\n\n\n\n\n\n\n\n\n\nEagle Swing Takes Off\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nSep 19, 2025\n\n\nAli Zaidi\n\n\n\n\n\nNo matching items"
  }
]